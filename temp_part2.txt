                type: 'startGame',
                game: gameType,
                gameData: gameData
            });
        }

        function loadGame(gameType, gameData) {
            gameState.currentGame = gameType;

            if (gameType === 'trivia') {
                showScreen('triviaScreen');
                if (gameData) loadTriviaGame(gameData);
            } else if (gameType === 'wordweb') {
                showScreen('wordwebScreen');
                if (gameData) loadWordwebGame(gameData);
            } else if (gameType === 'truthlie') {
                showScreen('truthlieScreen');
                if (gameData) loadTruthlieGame(gameData);
            } else if (gameType === 'quickdraw-ffa' || gameType === 'quickdraw-teams') {
                showScreen('quickdrawScreen');
                if (gameData) loadQuickdrawGame(gameData);
            }
        }

        function getCurrentGameData() {
            if (gameState.currentGame === 'trivia') return triviaGameState;
            if (gameState.currentGame === 'wordweb') return wordwebGameState;
            if (gameState.currentGame === 'truthlie') return truthlieGameState;
            if (gameState.currentGame === 'quickdraw-ffa' || gameState.currentGame === 'quickdraw-teams') return quickdrawGameState;
            return null;
        }

        function updateGameData(data) {
            if (gameState.currentGame === 'trivia') {
                updateTriviaGame(data);
            } else if (gameState.currentGame === 'wordweb') {
                updateWordwebGame(data);
            } else if (gameState.currentGame === 'truthlie') {
                updateTruthlieGame(data);
            } else if (gameState.currentGame === 'quickdraw-ffa' || gameState.currentGame === 'quickdraw-teams') {
                updateQuickdrawGame(data);
            }
        }

        function updateAllScoreboards() {
            updateScoreboard('triviaScoreboard');
            updateScoreboard('wordwebScoreboard');
            updateScoreboard('truthlieScoreboard');
            updateScoreboard('quickdrawScoreboard');
            updateScoreboard('finalScoreboard');
        }

        function updateScoreboard(elementId) {
            const element = document.getElementById(elementId);
            if (!element) return;

            element.innerHTML = '';
            const sortedPlayers = Object.keys(gameState.scores).sort((a, b) => {
                return gameState.scores[b] - gameState.scores[a];
            });

            sortedPlayers.forEach((playerId, index) => {
                const player = gameState.players[playerId];
                if (!player) return;

                const item = document.createElement('div');
                item.className = 'score-item';
                const medal = index === 0 ? 'ü•á ' : index === 1 ? 'ü•à ' : index === 2 ? 'ü•â ' : '';
                item.innerHTML = `
                    <span>${medal}${player.name}</span>
                    <span style="color: #667eea; font-weight: bold;">${gameState.scores[playerId]} pts</span>
                `;
                element.appendChild(item);
            });
        }

        function updateFinalTeamScoreboard() {
            const element = document.getElementById('finalScoreboard');
            if (!element) return;

            // Build Team A members list
            let teamAMembers = quickdrawGameState.teams.teamA.map(playerId => {
                const player = gameState.players[playerId];
                return player ? player.name : 'Unknown';
            }).join(', ');

            // Build Team B members list
            let teamBMembers = quickdrawGameState.teams.teamB.map(playerId => {
                const player = gameState.players[playerId];
                return player ? player.name : 'Unknown';
            }).join(', ');

            // Determine winner
            const teamAScore = quickdrawGameState.teamScores.teamA;
            const teamBScore = quickdrawGameState.teamScores.teamB;
            const teamAWon = teamAScore > teamBScore;
            const teamBWon = teamBScore > teamAScore;
            const tie = teamAScore === teamBScore;

            element.innerHTML = `
                <div class="score-item" style="flex-direction: column; align-items: flex-start;">
                    <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 5px;">
                        <span style="font-weight: bold;">${teamAWon ? 'ü•á ' : tie ? 'ü•à ' : 'ü•à '}Team A</span>
                        <span style="color: #667eea; font-weight: bold;">${teamAScore} pts</span>
                    </div>
                    <div style="font-size: 0.9em; color: #666;">${teamAMembers}</div>
                </div>
                <div class="score-item" style="flex-direction: column; align-items: flex-start;">
                    <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 5px;">
                        <span style="font-weight: bold;">${teamBWon ? 'ü•á ' : tie ? 'ü•à ' : 'ü•à '}Team B</span>
                        <span style="color: #764ba2; font-weight: bold;">${teamBScore} pts</span>
                    </div>
                    <div style="font-size: 0.9em; color: #666;">${teamBMembers}</div>
                </div>
            `;
        }

        function updateFinalCodenamesScoreboard() {
            const element = document.getElementById('finalScoreboard');
            if (!element) return;

            // Build Team A members list with spymaster indicator
            let teamAMembers = wordwebGameState.teams.teamA.map(playerId => {
                const player = gameState.players[playerId];
                const isSpymaster = playerId === wordwebGameState.spymasters.teamA;
                return player ? (player.name + (isSpymaster ? ' üëÅÔ∏è' : '')) : 'Unknown';
            }).join(', ');

            // Build Team B members list with spymaster indicator
            let teamBMembers = wordwebGameState.teams.teamB.map(playerId => {
                const player = gameState.players[playerId];
                const isSpymaster = playerId === wordwebGameState.spymasters.teamB;
                return player ? (player.name + (isSpymaster ? ' üëÅÔ∏è' : '')) : 'Unknown';
            }).join(', ');

            // Determine winner based on words remaining (team with 0 remaining won)
            const teamAWon = wordwebGameState.winner === 'teamA';
            const teamBWon = wordwebGameState.winner === 'teamB';
            const teamAWordsLeft = wordwebGameState.wordsRemaining.teamA;
            const teamBWordsLeft = wordwebGameState.wordsRemaining.teamB;

            element.innerHTML = `
                <div class="score-item" style="flex-direction: column; align-items: flex-start;">
                    <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 5px;">
                        <span style="font-weight: bold;">${teamAWon ? 'ü•á ' : 'ü•à '}Team A</span>
                        <span style="color: #667eea; font-weight: bold;">${teamAWon ? 'WINNER!' : teamAWordsLeft + ' words left'}</span>
                    </div>
                    <div style="font-size: 0.9em; color: #666;">${teamAMembers}</div>
                </div>
                <div class="score-item" style="flex-direction: column; align-items: flex-start;">
                    <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 5px;">
                        <span style="font-weight: bold;">${teamBWon ? 'ü•á ' : 'ü•à '}Team B</span>
                        <span style="color: #764ba2; font-weight: bold;">${teamBWon ? 'WINNER!' : teamBWordsLeft + ' words left'}</span>
                    </div>
                    <div style="font-size: 0.9em; color: #666;">${teamBMembers}</div>
                </div>
            `;
        }

        function endGame() {
            // Store if we're ending a team-based game
            const isQuickdrawTeamMode = quickdrawGameState.teamMode;
            const isCodenamesMode = wordwebGameState.teams && wordwebGameState.teams.teamA && wordwebGameState.teams.teamA.length > 0;

            gameState.currentGame = null;

            // Clear any active timers
            if (triviaGameState.timer) clearInterval(triviaGameState.timer);
            if (quickdrawGameState.timer) clearInterval(quickdrawGameState.timer);

            showScreen('resultsScreen');

            // Show appropriate scoreboard
            if (isQuickdrawTeamMode) {
                updateFinalTeamScoreboard();
            } else if (isCodenamesMode) {
                updateFinalCodenamesScoreboard();
            } else {
                updateScoreboard('finalScoreboard');
            }

            if (gameState.isHost) {
                document.getElementById('resultsHostControls').style.display = 'block';

                // Broadcast end game to all players
                broadcast({
                    type: 'endGame',
                    scores: gameState.scores,
                    players: gameState.players,
                    isQuickdrawTeamMode: isQuickdrawTeamMode,
                    isCodenamesMode: isCodenamesMode,
                    quickdrawTeamData: isQuickdrawTeamMode ? {
                        teams: quickdrawGameState.teams,
                        teamScores: quickdrawGameState.teamScores
                    } : null,
                    codenamesTeamData: isCodenamesMode ? {
                        teams: wordwebGameState.teams,
                        wordsRemaining: wordwebGameState.wordsRemaining,
                        winner: wordwebGameState.winner,
                        spymasters: wordwebGameState.spymasters
                    } : null
                });
            }
        }

        function returnToLobby() {
            gameState.currentGame = null;

            // Reset all scores to 0
            Object.keys(gameState.scores).forEach(playerId => {
                gameState.scores[playerId] = 0;
            });

            showScreen('lobbyScreen');
            updateLobbyPlayers();

            if (gameState.isHost) {
                broadcast({
                    type: 'returnToLobby',
                    scores: gameState.scores
                });
            }
        }

        // ===== TRIVIA GAME =====
        const allTriviaQuestions = [
            {
                question: "What does TDS stand for?",
                answers: ["The Dispute Service", "Technology Data Systems", "Total Digital Solutions", "Technical Development Service"],
                correct: 0
            },
            {
                question: "In what year was the first iPhone released?",
                answers: ["2005", "2007", "2009", "2010"],
                correct: 1
            },
            {
                question: "Which planet is known as the Red Planet?",
                answers: ["Venus", "Jupiter", "Mars", "Saturn"],
                correct: 2
            },
            {
                question: "What is the capital of Australia?",
                answers: ["Sydney", "Melbourne", "Canberra", "Brisbane"],
                correct: 2
            },
            {
                question: "Who painted the Mona Lisa?",
                answers: ["Van Gogh", "Picasso", "Da Vinci", "Rembrandt"],
                correct: 2
            },
            {
                question: "What is the most popular programming language in 2024?",
                answers: ["Python", "Java", "JavaScript", "C++"],
                correct: 0
            },
            {
                question: "What year did the Internet become publicly available?",
                answers: ["1983", "1991", "1995", "2000"],
                correct: 1
            },
            {
                question: "How many players are on a football team on the field at once?",
                answers: ["9", "10", "11", "12"],
                correct: 2
            },
            {
                question: "What is the largest ocean on Earth?",
                answers: ["Atlantic", "Indian", "Arctic", "Pacific"],
                correct: 3
            },
            {
                question: "Which company owns YouTube?",
                answers: ["Facebook", "Google", "Microsoft", "Amazon"],
                correct: 1
            },
            {
                question: "How many sides does a hexagon have?",
                answers: ["5", "6", "7", "8"],
                correct: 1
            },
            {
                question: "What is the smallest country in the world?",
                answers: ["Monaco", "Vatican City", "San Marino", "Liechtenstein"],
                correct: 1
            },
            {
                question: "Which programming language is known as the 'language of the web'?",
                answers: ["Python", "JavaScript", "Ruby", "PHP"],
                correct: 1
            },
            {
                question: "What does HTML stand for?",
                answers: ["Hyper Text Markup Language", "High Tech Modern Language", "Home Tool Markup Language", "Hyperlinks and Text Markup Language"],
                correct: 0
            },
            {
                question: "How many continents are there?",
                answers: ["5", "6", "7", "8"],
                correct: 2
            },
            {
                question: "What is the speed of light?",
                answers: ["300,000 km/s", "150,000 km/s", "450,000 km/s", "600,000 km/s"],
                correct: 0
            },
            {
                question: "Who founded Microsoft?",
                answers: ["Steve Jobs", "Bill Gates", "Mark Zuckerberg", "Jeff Bezos"],
                correct: 1
            },
            {
                question: "What year was Facebook launched?",
                answers: ["2002", "2003", "2004", "2005"],
                correct: 2
            },
            {
                question: "Which element has the chemical symbol 'O'?",
                answers: ["Gold", "Oxygen", "Osmium", "Oganesson"],
                correct: 1
            },
            {
                question: "How many teeth does an adult human have?",
                answers: ["28", "30", "32", "34"],
                correct: 2
            },
            {
                question: "What is the capital of France?",
                answers: ["London", "Berlin", "Paris", "Madrid"],
                correct: 2
            },
            {
                question: "Which planet is closest to the Sun?",
                answers: ["Venus", "Mercury", "Mars", "Earth"],
                correct: 1
            },
            {
                question: "What does CPU stand for?",
                answers: ["Central Processing Unit", "Computer Personal Unit", "Central Program Utility", "Computer Processing Utility"],
                correct: 0
            },
            {
                question: "How many players are on a basketball team on the court?",
                answers: ["4", "5", "6", "7"],
                correct: 1
            },
            {
                question: "What is the largest mammal in the world?",
                answers: ["African Elephant", "Blue Whale", "Giraffe", "Polar Bear"],
                correct: 1
            },
            {
                question: "Which country invented pizza?",
                answers: ["France", "Spain", "Italy", "Greece"],
                correct: 2
            },
            {
                question: "What does WWW stand for in a website address?",
                answers: ["World Wide Web", "World Web Wide", "Wide World Web", "Web Wide World"],
                correct: 0
            },
            {
                question: "How many hours are in a day?",
                answers: ["12", "24", "36", "48"],
                correct: 1
            },
            {
                question: "What is the hardest natural substance on Earth?",
                answers: ["Gold", "Iron", "Diamond", "Titanium"],
                correct: 2
            },
            {
                question: "Which social media platform has a bird as its logo?",
                answers: ["Facebook", "Instagram", "Twitter/X", "Snapchat"],
                correct: 2
            },
            {
                question: "What year did World War II end?",
                answers: ["1943", "1944", "1945", "1946"],
                correct: 2
            },
            {
                question: "How many colors are in a rainbow?",
                answers: ["5", "6", "7", "8"],
                correct: 2
            },
            {
                question: "What is the capital of Japan?",
                answers: ["Beijing", "Seoul", "Tokyo", "Bangkok"],
                correct: 2
            },
            {
                question: "Which gas do plants absorb from the atmosphere?",
                answers: ["Oxygen", "Nitrogen", "Carbon Dioxide", "Hydrogen"],
                correct: 2
            },
            {
                question: "What does USB stand for?",
                answers: ["Universal Serial Bus", "United System Bus", "Universal System Block", "United Serial Block"],
                correct: 0
            },
            {
                question: "How many minutes are in an hour?",
                answers: ["50", "60", "70", "80"],
                correct: 1
            },
            {
                question: "Which streaming service is known for its original series 'Stranger Things'?",
                answers: ["Amazon Prime", "Netflix", "Disney+", "Hulu"],
                correct: 1
            },
            {
                question: "What is the smallest prime number?",
                answers: ["0", "1", "2", "3"],
                correct: 2
            },
            {
                question: "Which planet has the most moons?",
                answers: ["Jupiter", "Saturn", "Uranus", "Neptune"],
                correct: 1
            },
            {
                question: "What does AI stand for?",
                answers: ["Artificial Intelligence", "Automated Intelligence", "Advanced Interface", "Artificial Interface"],
                correct: 0
            }
        ];

        let triviaGameState = {
            questions: [],
            currentQuestionIndex: 0,
            totalQuestions: 15,
            timeLeft: 15,
            timer: null,
            playerAnswers: {},
            revealed: false
        };

        function initTriviaGame() {
            // Randomly select questions for this game
            const shuffled = [...allTriviaQuestions].sort(() => Math.random() - 0.5);
            triviaGameState.questions = shuffled.slice(0, Math.min(triviaGameState.totalQuestions, shuffled.length));

            triviaGameState.currentQuestionIndex = 0;
            triviaGameState.playerAnswers = {};
            triviaGameState.revealed = false;

            showScreen('triviaScreen');

            if (gameState.isHost) {
                document.getElementById('triviaHostControls').style.display = 'block';
            }

            // Update scoreboard to show current (reset) scores
            updateScoreboard('triviaScoreboard');

            loadTriviaQuestion();
            return triviaGameState;
        }

        function loadTriviaGame(data) {
            triviaGameState = data;
            renderTriviaQuestion();
            updateScoreboard('triviaScoreboard');
            if (gameState.isHost) {
                startTriviaTimer();
            }
        }

        function loadTriviaQuestion() {
            triviaGameState.playerAnswers = {};
            triviaGameState.revealed = false;
            triviaGameState.timeLeft = 15;
            
            renderTriviaQuestion();
            
            if (gameState.isHost) {
                startTriviaTimer();
                broadcastGameUpdate();
            }
        }

        function renderTriviaQuestion() {
            const question = triviaGameState.questions[triviaGameState.currentQuestionIndex];
            document.getElementById('triviaQuestion').textContent = question.question;
            document.getElementById('triviaTimer').textContent = triviaGameState.timeLeft;

            // Update progress indicator
            const progressText = `Question ${triviaGameState.currentQuestionIndex + 1} of ${triviaGameState.questions.length}`;
            document.getElementById('triviaProgress').textContent = progressText;

            const answersContainer = document.getElementById('triviaAnswers');
            answersContainer.innerHTML = '';

            question.answers.forEach((answer, index) => {
                const btn = document.createElement('button');
                btn.className = 'answer-btn';
                btn.textContent = answer;

                if (triviaGameState.revealed) {
                    btn.disabled = true;
                    if (index === question.correct) {
                        btn.classList.add('correct');
                    }
                    if (triviaGameState.playerAnswers[gameState.peerId]?.answer === index) {
                        btn.classList.add('selected');
                    }
                } else {
                    if (triviaGameState.playerAnswers[gameState.peerId]?.answer === index) {
                        btn.classList.add('selected');
                        btn.disabled = true;
                    } else {
                        btn.onclick = () => submitTriviaAnswer(index);
                    }
                }

                answersContainer.appendChild(btn);
            });

            const status = document.getElementById('triviaStatus');
            if (triviaGameState.revealed) {
                status.textContent = `Correct answer: ${question.answers[question.correct]}`;
                status.className = 'status-message status-success';
            } else if (triviaGameState.playerAnswers[gameState.peerId]) {
                status.textContent = 'Answer submitted! Waiting for others...';
                status.className = 'status-message status-info';
            } else {
                status.textContent = 'Choose your answer!';
                status.className = 'status-message status-info';
            }
        }

        function startTriviaTimer() {
            if (triviaGameState.timer) clearInterval(triviaGameState.timer);

            triviaGameState.timer = setInterval(() => {
                triviaGameState.timeLeft--;

                // Update timer display on host screen
                document.getElementById('triviaTimer').textContent = triviaGameState.timeLeft;

                if (triviaGameState.timeLeft <= 0) {
                    clearInterval(triviaGameState.timer);
                    revealTriviaAnswer();
                }

                broadcastGameUpdate();
            }, 1000);
        }

        function submitTriviaAnswer(answerIndex) {
            if (triviaGameState.playerAnswers[gameState.peerId]) return;

            const timestamp = Date.now();
            triviaGameState.playerAnswers[gameState.peerId] = {
                answer: answerIndex,
                timestamp: timestamp
            };

            renderTriviaQuestion();

            // Send to host if not host
            if (!gameState.isHost) {
                broadcast({
                    type: 'triviaAnswer',
                    playerId: gameState.peerId,
                    answer: answerIndex,
                    timestamp: timestamp
                });
            } else {
                // Host submitted answer, check if all players answered
                checkAllPlayersAnswered();
            }
        }

        function handleTriviaAnswer(playerId, answer, timestamp) {
            if (!gameState.isHost) return;

            triviaGameState.playerAnswers[playerId] = {
                answer: answer,
                timestamp: timestamp
            };

            broadcastGameUpdate();

            // Check if all players have answered
            checkAllPlayersAnswered();
        }

        function checkAllPlayersAnswered() {
            if (!gameState.isHost) return;
            if (triviaGameState.revealed) return;

            const totalPlayers = Object.keys(gameState.players).length;
            const answeredPlayers = Object.keys(triviaGameState.playerAnswers).length;

            if (answeredPlayers >= totalPlayers) {
                // All players have answered, reveal the answer
                clearInterval(triviaGameState.timer);
                revealTriviaAnswer();
            }
        }

        function revealTriviaAnswer() {
            if (!gameState.isHost) return;

            triviaGameState.revealed = true;
            const question = triviaGameState.questions[triviaGameState.currentQuestionIndex];

            // Get all correct answers sorted by response time (fastest first)
            const correctAnswers = Object.keys(triviaGameState.playerAnswers)
                .map(playerId => ({
                    playerId: playerId,
                    answer: triviaGameState.playerAnswers[playerId].answer,
                    timestamp: triviaGameState.playerAnswers[playerId].timestamp
                }))
                .filter(player => player.answer === question.correct)
                .sort((a, b) => a.timestamp - b.timestamp);

            // Award points based on speed ranking
            // Scoring system: 1st = 1000pts, 2nd = 800pts, 3rd = 600pts, 4th = 400pts, 5th = 300pts, 6th+ = 200pts
            const pointsTable = [1000, 800, 600, 400, 300, 200];

            correctAnswers.forEach((player, index) => {
                const points = index < pointsTable.length ? pointsTable[index] : 200;
                gameState.scores[player.playerId] = (gameState.scores[player.playerId] || 0) + points;
            });

            // Update host's display
            renderTriviaQuestion();
            updateScoreboard('triviaScoreboard');

            // Send to clients
            broadcastGameUpdate();
        }

        function nextTriviaQuestion() {
            if (!gameState.isHost) return;

            triviaGameState.currentQuestionIndex++;
            
            if (triviaGameState.currentQuestionIndex >= triviaGameState.questions.length) {
                endGame();
            } else {
                loadTriviaQuestion();
            }
        }

        function updateTriviaGame(data) {
            triviaGameState = data;
            renderTriviaQuestion();
            updateScoreboard('triviaScoreboard');
        }

        // ===== CODENAMES GAME =====
        let wordwebGameState = {
            words: ['AFRICA', 'AGENT', 'AIR', 'ALIEN', 'ALPS', 'AMAZON', 'AMBULANCE', 'AMERICA', 'ANGEL', 'ANTARCTICA',
                    'APPLE', 'ARM', 'ATLANTIS', 'AUSTRALIA', 'AZTEC', 'BACK', 'BALL', 'BAND', 'BANK', 'BAR',
                    'BARK', 'BAT', 'BATTERY', 'BEACH', 'BEAR', 'BEAT', 'BED', 'BEIJING', 'BELL', 'BELT',
                    'BERLIN', 'BERMUDA', 'BERRY', 'BILL', 'BLOCK', 'BOARD', 'BOLT', 'BOMB', 'BOND', 'BOOM',
                    'BOOT', 'BOTTLE', 'BOW', 'BOX', 'BRIDGE', 'BRUSH', 'BUCK', 'BUFFALO', 'BUG', 'BUGLE',
                    'BUTTON', 'CALF', 'CANADA', 'CAP', 'CAPITAL', 'CAR', 'CARD', 'CARROT', 'CASINO', 'CAST',
                    'CAT', 'CELL', 'CENTAUR', 'CENTER', 'CHAIR', 'CHANGE', 'CHARGE', 'CHECK', 'CHEST', 'CHICK',
                    'CHINA', 'CHOCOLATE', 'CHURCH', 'CIRCLE', 'CLIFF', 'CLOAK', 'CLUB', 'CODE', 'COLD', 'COMIC',
                    'COMPOUND', 'CONCERT', 'CONDUCTOR', 'CONTRACT', 'COOK', 'COPPER', 'COTTON', 'COURT', 'COVER', 'CRANE',
                    'CRASH', 'CRICKET', 'CROSS', 'CROWN', 'CYCLE', 'CZECH', 'DANCE', 'DATE', 'DAY', 'DEATH',
                    'DECK', 'DEGREE', 'DIAMOND', 'DICE', 'DINOSAUR', 'DISEASE', 'DOCTOR', 'DOG', 'DRAFT', 'DRAGON',
                    'DRESS', 'DRILL', 'DROP', 'DUCK', 'DWARF', 'EAGLE', 'EGYPT', 'EMBASSY', 'ENGINE', 'ENGLAND',
                    'EUROPE', 'EYE', 'FACE', 'FAIR', 'FALL', 'FAN', 'FENCE', 'FIELD', 'FIGHTER', 'FIGURE',
                    'FILE', 'FILM', 'FIRE', 'FISH', 'FLUTE', 'FLY', 'FOOT', 'FORCE', 'FOREST', 'FORK',
                    'FRANCE', 'GAME', 'GAS', 'GENIUS', 'GERMANY', 'GHOST', 'GIANT', 'GLASS', 'GLOVE', 'GOLD',
                    'GRACE', 'GRASS', 'GREECE', 'GREEN', 'GROUND', 'HAM', 'HAND', 'HAWK', 'HEAD', 'HEART',
                    'HELICOPTER', 'HIMALAYAS', 'HOLE', 'HOLLYWOOD', 'HONEY', 'HOOD', 'HOOK', 'HORN', 'HORSE', 'HORSESHOE',
                    'HOSPITAL', 'HOTEL', 'ICE', 'INDIA', 'IRON', 'IVORY', 'JACK', 'JAM', 'JET', 'JUPITER',
                    'KANGAROO', 'KETCHUP', 'KEY', 'KID', 'KING', 'KIWI', 'KNIFE', 'KNIGHT', 'LAB', 'LAP',
                    'LASER', 'LAWYER', 'LEAD', 'LEMON', 'LEPRECHAUN', 'LIFE', 'LIGHT', 'LIMOUSINE', 'LINE', 'LINK',
                    'LION', 'LITTER', 'LOCH NESS', 'LOCK', 'LOG', 'LONDON', 'LUCK', 'MAIL', 'MAMMOTH', 'MAPLE',
                    'MARBLE', 'MARCH', 'MASS', 'MATCH', 'MERCURY', 'MEXICO', 'MICROSCOPE', 'MILLIONAIRE', 'MINE', 'MINT',
                    'MISSILE', 'MODEL', 'MOLE', 'MOON', 'MOSCOW', 'MOUNT', 'MOUSE', 'MOUTH', 'MUG', 'NAIL',
                    'NEEDLE', 'NET', 'NEW YORK', 'NIGHT', 'NINJA', 'NOTE', 'NOVEL', 'NURSE', 'NUT', 'OCTOPUS',
                    'OIL', 'OLIVE', 'OLYMPUS', 'OPERA', 'ORANGE', 'ORGAN', 'PALM', 'PAN', 'PANTS', 'PAPER',
                    'PARACHUTE', 'PARK', 'PART', 'PASS', 'PASTE', 'PENGUIN', 'PHOENIX', 'PIANO', 'PIE', 'PILOT',
                    'PIN', 'PIPE', 'PIRATE', 'PISTOL', 'PIT', 'PITCH', 'PLANE', 'PLASTIC', 'PLATE', 'PLATYPUS',
                    'PLAY', 'PLOT', 'POINT', 'POISON', 'POLE', 'POLICE', 'POOL', 'PORT', 'POST', 'POUND',
                    'PRESS', 'PRINCESS', 'PUMPKIN', 'PUPIL', 'PYRAMID', 'QUEEN', 'RABBIT', 'RACKET', 'RAY', 'REVOLUTION',
                    'RING', 'ROBIN', 'ROBOT', 'ROCK', 'ROME', 'ROOT', 'ROSE', 'ROULETTE', 'ROUND', 'ROW',
                    'RULER', 'SATELLITE', 'SATURN', 'SCALE', 'SCHOOL', 'SCIENTIST', 'SCORPION', 'SCREEN', 'SCUBA', 'SEAL',
                    'SERVER', 'SHADOW', 'SHAKESPEARE', 'SHARK', 'SHIP', 'SHOE', 'SHOP', 'SHOT', 'SINK', 'SKYSCRAPER',
                    'SLIP', 'SLUG', 'SMUGGLER', 'SNOW', 'SOCK', 'SOLDIER', 'SOUL', 'SOUND', 'SPACE', 'SPELL',
                    'SPIDER', 'SPIKE', 'SPINE', 'SPOT', 'SPRING', 'SPY', 'SQUARE', 'STADIUM', 'STAFF', 'STAR',
                    'STATE', 'STICK', 'STOCK', 'STRAW', 'STREAM', 'STRIKE', 'STRING', 'SUB', 'SUIT', 'SUPERHERO',
                    'SWING', 'SWITCH', 'TABLE', 'TABLET', 'TAG', 'TAIL', 'TAP', 'TEACHER', 'TELESCOPE', 'TEMPLE',
                    'TEXAS', 'THIEF', 'THUMB', 'TICK', 'TIE', 'TIME', 'TOKYO', 'TOOTH', 'TORCH', 'TOWER',
                    'TRACK', 'TRAIN', 'TRIANGLE', 'TRIP', 'TRUNK', 'TUBE', 'TURKEY', 'UNDERTAKER', 'UNICORN', 'VACUUM',
                    'VAN', 'VET', 'WAKE', 'WALL', 'WAR', 'WASHER', 'WASHINGTON', 'WATCH', 'WATER', 'WAVE',
                    'WEB', 'WELL', 'WHALE', 'WHIP', 'WIND', 'WITCH', 'WORM', 'YARD'],
            grid: [],
            teams: {
                teamA: [],  // Player IDs on Team A
                teamB: []   // Player IDs on Team B
            },
            spymasters: {
                teamA: null,  // Spymaster for Team A
                teamB: null   // Spymaster for Team B
            },
            currentTeam: 'teamA',  // 'teamA' or 'teamB'
            wordsRemaining: { teamA: 0, teamB: 0, neutral: 0 },
            currentClue: null,  // { word: 'example', number: 3 }
            guessesLeft: 0,
            gameOver: false,
            winner: null
        };

        function showTeamSelectionForCodenames() {
            if (!gameState.isHost) return;

            gameState.currentGame = 'wordweb';
            showTeamSelectionScreen();
        }

        function startCodenamesWithTeams() {
            // Validate teams
            if (teamSelection.teamA.length < 2 || teamSelection.teamB.length < 2) {
                alert('Each team must have at least 2 players (1 spymaster + 1 operative)!');
                return;
            }

            // Validate spymasters are selected
            if (!teamSelection.spymasterA || !teamSelection.spymasterB) {
                alert('Please select a Spymaster for each team!');
                return;
            }

            // Initialize game with manual team assignment
            const gameData = initWordwebGameWithTeams(
                teamSelection.teamA,
                teamSelection.teamB,
                teamSelection.spymasterA,
                teamSelection.spymasterB
            );

            broadcast({
                type: 'startGame',
                game: 'wordweb',
                gameData: gameData
            });
        }

        function initWordwebGameWithTeams(teamAPlayers, teamBPlayers, spymasterA, spymasterB) {
            showScreen('wordwebScreen');

            // Assign teams
            wordwebGameState.teams.teamA = teamAPlayers;
            wordwebGameState.teams.teamB = teamBPlayers;

            // Assign spymasters from selection
            wordwebGameState.spymasters.teamA = spymasterA;
            wordwebGameState.spymasters.teamB = spymasterB;

            // Generate grid - Codenames has 9 for one team, 8 for other, 7 neutral, 1 assassin
            wordwebGameState.grid = [];
            const shuffled = [...wordwebGameState.words].sort(() => Math.random() - 0.5).slice(0, 25);

            // Randomly decide which team gets 9 cards (starting team)
            const firstTeam = Math.random() < 0.5 ? 'teamA' : 'teamB';
            wordwebGameState.currentTeam = firstTeam;

            for (let i = 0; i < 25; i++) {
                let type;
                if (i < 9) {
                    type = firstTeam; // First team gets 9 words
                } else if (i < 17) {
                    type = firstTeam === 'teamA' ? 'teamB' : 'teamA'; // Other team gets 8 words
                } else if (i < 24) {
                    type = 'neutral'; // 7 neutral
                } else {
                    type = 'assassin'; // 1 assassin
                }

                wordwebGameState.grid.push({
                    word: shuffled[i],
                    type: type,
                    revealed: false
                });
            }

            // Shuffle grid
            wordwebGameState.grid.sort(() => Math.random() - 0.5);

            // Count words remaining
            wordwebGameState.wordsRemaining = {
                teamA: wordwebGameState.grid.filter(c => c.type === 'teamA').length,
                teamB: wordwebGameState.grid.filter(c => c.type === 'teamB').length,
                neutral: 7
            };

            wordwebGameState.currentClue = null;
            wordwebGameState.guessesLeft = 0;
            wordwebGameState.gameOver = false;
            wordwebGameState.winner = null;

            if (gameState.isHost) {
                document.getElementById('wordwebHostControls').style.display = 'block';
            }

            updateCodenamesUI();

            return wordwebGameState;
        }

        function initWordwebGame() {
            // This is called for backward compatibility - redirect to team selection
            showTeamSelectionForCodenames();
        }

        function loadWordwebGame(data) {
            wordwebGameState = data;
            updateCodenamesUI();
        }

        function updateCodenamesUI() {
            renderWordwebGrid();
            renderSpymasterKey();
            updateWordwebTeamDisplay();
            updateClueDisplay();
            updateSpymasterSection();
        }

        function renderSpymasterKey() {
            const keyGrid = document.getElementById('spymasterKeyGrid');
            const keySection = document.getElementById('spymasterKey');

            // Check if current player is a spymaster
            const isSpymaster = gameState.peerId === wordwebGameState.spymasters.teamA ||
                               gameState.peerId === wordwebGameState.spymasters.teamB;

            if (isSpymaster) {
                keySection.style.display = 'block';
                keyGrid.innerHTML = '';

                wordwebGameState.grid.forEach(cell => {
                    const keyCard = document.createElement('div');
                    keyCard.style.cssText = 'padding: 8px; text-align: center; border-radius: 5px; font-weight: bold; font-size: 0.85em;';
                    keyCard.textContent = cell.word;

                    if (cell.type === 'teamA') {
                        keyCard.style.background = '#667eea';
                        keyCard.style.color = 'white';
                    } else if (cell.type === 'teamB') {
                        keyCard.style.background = '#764ba2';
                        keyCard.style.color = 'white';
                    } else if (cell.type === 'neutral') {
                        keyCard.style.background = '#f0f0f0';
                        keyCard.style.color = '#333';
                    } else if (cell.type === 'assassin') {
                        keyCard.style.background = '#000';
                        keyCard.style.color = 'white';
                    }

                    if (cell.revealed) {
                        keyCard.style.opacity = '0.4';
                        keyCard.style.textDecoration = 'line-through';
                    }

                    keyGrid.appendChild(keyCard);
                });
            } else {
                keySection.style.display = 'none';
            }
        }

        function renderWordwebGrid() {
            const grid = document.getElementById('wordwebGrid');
            grid.innerHTML = '';

            wordwebGameState.grid.forEach((cell, index) => {
                const card = document.createElement('div');
                card.className = 'word-card';
                card.textContent = cell.word;

                if (cell.revealed) {
                    // Show color based on type
                    if (cell.type === 'teamA') {
                        card.style.background = '#667eea';
                        card.style.color = 'white';
                    } else if (cell.type === 'teamB') {
                        card.style.background = '#764ba2';
                        card.style.color = 'white';
                    } else if (cell.type === 'neutral') {
                        card.style.background = '#f0f0f0';
                        card.style.color = '#333';
                    } else if (cell.type === 'assassin') {
                        card.style.background = '#000';
                        card.style.color = 'white';
                    }
                } else {
                    // Check if player is an operative on current team and can click
                    const canClick = isCurrentTeamOperative() && !wordwebGameState.gameOver;
                    if (canClick && wordwebGameState.guessesLeft > 0) {
                        card.onclick = () => selectWord(index);
                        card.style.cursor = 'pointer';
                    }
                }

                grid.appendChild(card);
            });
        }

        function isCurrentTeamOperative() {
            const currentTeam = wordwebGameState.currentTeam;
            const isOnCurrentTeam = wordwebGameState.teams[currentTeam].includes(gameState.peerId);
            const isSpymaster = gameState.peerId === wordwebGameState.spymasters[currentTeam];
            return isOnCurrentTeam && !isSpymaster;
        }

        function isCurrentTeamSpymaster() {
            const currentTeam = wordwebGameState.currentTeam;
            return gameState.peerId === wordwebGameState.spymasters[currentTeam];
        }

        function updateSpymasterSection() {
            const section = document.getElementById('spymasterClueSection');

            if (isCurrentTeamSpymaster() && !wordwebGameState.currentClue && !wordwebGameState.gameOver) {
                section.style.display = 'block';
            } else {
                section.style.display = 'none';
            }
        }

        function updateClueDisplay() {
            const display = document.getElementById('currentClueDisplay');
            const clueText = document.getElementById('currentClueText');
            const guessesRem = document.getElementById('guessesRemaining');

            if (wordwebGameState.currentClue && wordwebGameState.guessesLeft > 0) {
                display.style.display = 'block';
                clueText.textContent = `${wordwebGameState.currentClue.word} (${wordwebGameState.currentClue.number})`;
                guessesRem.textContent = wordwebGameState.guessesLeft;
            } else {
                display.style.display = 'none';
            }
        }

        function giveClue() {
            if (!gameState.isHost) {
                // Send clue to host
                const word = document.getElementById('clueWord').value.trim().toUpperCase();
                const number = parseInt(document.getElementById('clueNumber').value);

                if (!word || !number || number < 1 || number > 9) {
                    alert('Please enter a valid one-word clue and a number between 1-9');
                    return;
                }

                broadcast({
                    type: 'codenamesClue',
                    word: word,
                    number: number
                });

                return;
            }

            handleCodenamesClue(null,
                document.getElementById('clueWord').value.trim().toUpperCase(),
                parseInt(document.getElementById('clueNumber').value)
            );
        }

        function handleCodenamesClue(playerId, word, number) {
            if (!gameState.isHost) return;

            if (!word || !number || number < 1 || number > 9) {
                return;
            }

            wordwebGameState.currentClue = { word, number };
            wordwebGameState.guessesLeft = number + 1; // Can make one extra guess

            // Clear inputs
            document.getElementById('clueWord').value = '';
            document.getElementById('clueNumber').value = '';

            broadcastGameUpdate();
            updateCodenamesUI();
        }

        function selectWord(index) {
            if (wordwebGameState.grid[index].revealed) return;
            if (wordwebGameState.guessesLeft <= 0) return;
            if (!isCurrentTeamOperative()) return;

            if (gameState.isHost) {
                handleWordwebSelect(index);
            } else {
                broadcast({
                    type: 'wordwebSelect',
                    index: index
                });
            }
        }

        function handleWordwebSelect(index) {
            if (!gameState.isHost) return;
            if (wordwebGameState.grid[index].revealed) return;

            wordwebGameState.grid[index].revealed = true;
            const cell = wordwebGameState.grid[index];

            // Decrease guesses left
            wordwebGameState.guessesLeft--;

            // Update words remaining
            if (cell.type === 'teamA') {
                wordwebGameState.wordsRemaining.teamA--;
            } else if (cell.type === 'teamB') {
                wordwebGameState.wordsRemaining.teamB--;
            } else if (cell.type === 'neutral') {
                wordwebGameState.wordsRemaining.neutral--;
            }

            // Check win/loss conditions
            if (cell.type === 'assassin') {
                // Team that picked assassin loses
                wordwebGameState.gameOver = true;
                wordwebGameState.winner = wordwebGameState.currentTeam === 'teamA' ? 'teamB' : 'teamA';
                setTimeout(() => endGame(), 2000);
            } else if (wordwebGameState.wordsRemaining.teamA === 0) {
                // Team A wins
                wordwebGameState.gameOver = true;
                wordwebGameState.winner = 'teamA';
                setTimeout(() => endGame(), 2000);
            } else if (wordwebGameState.wordsRemaining.teamB === 0) {
                // Team B wins
                wordwebGameState.gameOver = true;
                wordwebGameState.winner = 'teamB';
                setTimeout(() => endGame(), 2000);
            } else if (cell.type !== wordwebGameState.currentTeam || wordwebGameState.guessesLeft === 0) {
                // Wrong team's word or out of guesses - end turn
                switchWordwebTeam();
            }

            broadcastGameUpdate();
            updateCodenamesUI();
        }

        function endTurn() {
            if (!gameState.isHost) return;
            switchWordwebTeam();
        }

        function switchWordwebTeam() {
            wordwebGameState.currentTeam = wordwebGameState.currentTeam === 'teamA' ? 'teamB' : 'teamA';
            wordwebGameState.currentClue = null;
            wordwebGameState.guessesLeft = 0;

            if (gameState.isHost) {
                broadcastGameUpdate();
            }

            updateCodenamesUI();
        }

        function updateWordwebTeamDisplay() {
            const teamName = wordwebGameState.currentTeam === 'teamA' ? 'Team A' : 'Team B';
            const teamDiv = document.getElementById('wordwebTeam');
            teamDiv.textContent = `${teamName}'s Turn`;
            teamDiv.className = 'team-indicator';
            teamDiv.style.background = wordwebGameState.currentTeam === 'teamA' ? '#667eea' : '#764ba2';

            const scoreboard = document.getElementById('wordwebScoreboard');

            // Build Team A members list
            let teamAMembers = wordwebGameState.teams.teamA.map(playerId => {
                const player = gameState.players[playerId];
                const isSpymaster = playerId === wordwebGameState.spymasters.teamA;
                return player ? (player.name + (isSpymaster ? ' üëÅÔ∏è' : '')) : 'Unknown';
            }).join(', ');

            // Build Team B members list
            let teamBMembers = wordwebGameState.teams.teamB.map(playerId => {
                const player = gameState.players[playerId];
                const isSpymaster = playerId === wordwebGameState.spymasters.teamB;
                return player ? (player.name + (isSpymaster ? ' üëÅÔ∏è' : '')) : 'Unknown';
            }).join(', ');

            scoreboard.innerHTML = `
                <div class="score-item" style="flex-direction: column; align-items: flex-start;">
                    <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 5px;">
                        <span style="font-weight: bold;">Team A</span>
                        <span style="color: #667eea; font-weight: bold;">${wordwebGameState.wordsRemaining.teamA} words left</span>
                    </div>
                    <div style="font-size: 0.9em; color: #666;">${teamAMembers}</div>
                </div>
                <div class="score-item" style="flex-direction: column; align-items: flex-start;">
                    <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 5px;">
                        <span style="font-weight: bold;">Team B</span>
                        <span style="color: #764ba2; font-weight: bold;">${wordwebGameState.wordsRemaining.teamB} words left</span>
                    </div>
                    <div style="font-size: 0.9em; color: #666;">${teamBMembers}</div>
                </div>
            `;

            // Update status message
            const status = document.getElementById('wordwebStatus');
            if (wordwebGameState.gameOver) {
                const winnerName = wordwebGameState.winner === 'teamA' ? 'Team A' : 'Team B';
                status.textContent = `üéâ ${winnerName} Wins!`;
                status.className = 'status-message status-success';
            } else if (isCurrentTeamSpymaster()) {
                status.textContent = 'You are the Spymaster! Give your team a clue.';
                status.className = 'status-message status-info';
            } else if (isCurrentTeamOperative()) {
                if (wordwebGameState.currentClue) {
                    status.textContent = 'Your Spymaster gave a clue! Click words to guess.';
                    status.className = 'status-message status-success';
                } else {
                    status.textContent = 'Waiting for your Spymaster to give a clue...';
                    status.className = 'status-message status-warning';
                }
            } else {
                status.textContent = 'Spectating: Watch the other team play.';
                status.className = 'status-message status-warning';
            }
        }

        function updateWordwebGame(data) {
            wordwebGameState = data;
            updateCodenamesUI();
        }

        function toggleCodenamesRules() {
            const rulesSection = document.getElementById('codenamesRules');
            if (rulesSection.style.display === 'none') {
                rulesSection.style.display = 'block';
            } else {
                rulesSection.style.display = 'none';
            }
        }

        // ===== TRUTH & LIE GAME =====
        let truthlieGameState = {
            rounds: [
                {
                    topic: "About TDS",
                    statements: [
                        { text: "TDS handles over 10,000 disputes annually", truth: true },
                        { text: "TDS was founded in 2003", truth: true },
                        { text: "TDS only operates in England", truth: false }
                    ]
                },
                {
                    topic: "Tech Facts",
                    statements: [
                        { text: "The first computer bug was an actual moth", truth: true },
                        { text: "CAPTCHA stands for 'Computer Automated Public Test'", truth: false },
                        { text: "The first domain ever registered was Symbolics.com", truth: true }
                    ]
                },
                {
                    topic: "Pop Culture",
                    statements: [
                        { text: "The first YouTube video was uploaded in 2005", truth: true },
                        { text: "Netflix started as a DVD rental service", truth: true },
                        { text: "The iPhone was the first smartphone ever made", truth: false }
                    ]
                },
                {
                    topic: "Office Life",
                    statements: [
                        { text: "The average office worker spends 5 hours a day in meetings", truth: false },
                        { text: "Standing desks burn about 50 extra calories per hour", truth: true },
                        { text: "Monday is the most productive day of the week", truth: true }
                    ]
                },
                {
                    topic: "Random Facts",
                    statements: [
                        { text: "Honey never spoils", truth: true },
                        { text: "Bananas are berries but strawberries aren't", truth: true },
                        { text: "Goldfish have a 3-second memory", truth: false }
                    ]
                }
            ],
            currentRoundIndex: 0,
            votes: {},
            revealed: false
        };

        function initTruthlieGame() {
            showScreen('truthlieScreen');
            
            truthlieGameState.currentRoundIndex = 0;
            truthlieGameState.votes = {};
            truthlieGameState.revealed = false;
            
            if (gameState.isHost) {
                document.getElementById('truthlieHostControls').style.display = 'block';
            }

            renderTruthlieRound();
            
            return truthlieGameState;
        }

        function loadTruthlieGame(data) {
            truthlieGameState = data;
            renderTruthlieRound();
        }

        function renderTruthlieRound() {
            const round = truthlieGameState.rounds[truthlieGameState.currentRoundIndex];
            
            document.getElementById('truthliePlayer').textContent = round.topic;
            
            const container = document.getElementById('truthlieStatements');
            container.innerHTML = '';

            round.statements.forEach((statement, index) => {
                const card = document.createElement('div');
                card.className = 'statement-card';
                
                if (truthlieGameState.revealed) {
                    const emoji = statement.truth ? '‚úÖ' : '‚ùå';
                    card.textContent = `${emoji} ${statement.text}`;
                    card.style.background = statement.truth ? '#E8F5E9' : '#FFEBEE';
                    card.style.color = statement.truth ? '#388E3C' : '#C62828';
                } else {
                    card.textContent = `${index + 1}. ${statement.text}`;
                    if (truthlieGameState.votes[gameState.peerId] === index) {
                        card.classList.add('selected');
                    }
                    card.onclick = () => voteForLie(index);
                }

                container.appendChild(card);
            });

            const status = document.getElementById('truthlieStatus');
            if (truthlieGameState.revealed) {
                status.textContent = 'Answer revealed! Moving to next round...';
                status.className = 'status-message status-success';
            } else {
                status.textContent = 'Which statement is the LIE?';
                status.className = 'status-message status-info';
            }
        }

        function voteForLie(index) {
            if (truthlieGameState.revealed) return;

            truthlieGameState.votes[gameState.peerId] = index;
            renderTruthlieRound();

            if (!gameState.isHost) {
                broadcast({
                    type: 'truthlieVote',
                    playerId: gameState.peerId,
                    vote: index
                });
            }
        }

        function handleTruthlieVote(playerId, vote) {
            if (!gameState.isHost) return;
            
            truthlieGameState.votes[playerId] = vote;
            broadcastGameUpdate();
        }

        function revealTruthlieAnswer() {
            if (!gameState.isHost) return;

            truthlieGameState.revealed = true;
            const round = truthlieGameState.rounds[truthlieGameState.currentRoundIndex];
            const lieIndex = round.statements.findIndex(s => !s.truth);
            
            // Award points
            Object.keys(truthlieGameState.votes).forEach(playerId => {
                if (truthlieGameState.votes[playerId] === lieIndex) {
                    gameState.scores[playerId] = (gameState.scores[playerId] || 0) + 100;
                }
            });

            broadcastGameUpdate();
            renderTruthlieRound();
            updateScoreboard('truthlieScoreboard');
        }

        function nextTruthlieRound() {
            if (!gameState.isHost) return;

            truthlieGameState.currentRoundIndex++;
            
            if (truthlieGameState.currentRoundIndex >= truthlieGameState.rounds.length) {
                endGame();
            } else {
                truthlieGameState.votes = {};
                truthlieGameState.revealed = false;
                broadcastGameUpdate();
                renderTruthlieRound();
            }
        }

        function updateTruthlieGame(data) {
            truthlieGameState = data;
            renderTruthlieRound();
            updateScoreboard('truthlieScoreboard');
        }

        // ===== QUICK DRAW GAME =====
        let quickdrawGameState = {
            prompts: [
                // Simple Objects
                'House', 'Cat', 'Car', 'Tree', 'Phone', 'Computer', 'Pizza', 'Sun', 'Flower', 'Rocket',
                'Dog', 'Bird', 'Fish', 'Boat', 'Bicycle', 'Clock', 'Star', 'Moon', 'Cloud', 'Rainbow',

                // Animals
                'Elephant', 'Giraffe', 'Penguin', 'Octopus', 'Dinosaur', 'Chicken', 'Cow', 'Pig', 'Sheep',
                'Kangaroo', 'Turtle', 'Flamingo', 'Snail', 'Butterfly', 'Ladybug', 'Crab', 'Whale', 'Dolphin',

                // Food & Drink
                'Hamburger', 'Hot Dog', 'Sushi', 'Taco', 'Ice Cream Cone', 'Birthday Cake', 'Donut',
                'Banana', 'Pineapple', 'Watermelon', 'Coffee Cup', 'Tea Pot', 'Sandwich', 'Popcorn',

                // Office & Work
                'Office Chair', 'Laptop', 'Coffee Mug', 'Stapler', 'Filing Cabinet', 'Desk Lamp',
                'Printer', 'Calculator', 'Sticky Notes', 'Water Cooler', 'Conference Room', 'Whiteboard',
                'Tie', 'Briefcase', 'Name Tag', 'Keyboard', 'Mouse Pad', 'Headphones',

                // Household Items
                'Toaster', 'Microwave', 'Toilet', 'Shower', 'Washing Machine', 'Vacuum Cleaner',
                'Ceiling Fan', 'Couch', 'Pillow', 'Blanket', 'Lamp', 'TV Remote', 'Toothbrush',

                // Transportation
                'Helicopter', 'Hot Air Balloon', 'Submarine', 'Skateboard', 'Scooter', 'Train',
                'Airplane', 'UFO', 'Sailboat', 'Rollerblades', 'Shopping Cart',

                // Sports & Activities
                'Soccer Ball', 'Basketball Hoop', 'Tennis Racket', 'Golf Club', 'Bowling Pin',
                'Dumbbell', 'Jump Rope', 'Frisbee', 'Yoga Mat', 'Running Shoe',

                // Nature & Weather
                'Lightning Bolt', 'Tornado', 'Volcano', 'Mountain', 'Cactus', 'Palm Tree', 'Snowman',
                'Campfire', 'Tent', 'Beach Umbrella', 'Sunset',

                // Funny/Silly
                'Person Tripping', 'Someone Sneezing', 'Brain Freeze', 'Stuck in Traffic',
                'Monday Morning', 'Forgot Password', 'Low Battery', 'Tangled Headphones', 'Autocorrect Fail',
                'Stepping on LEGO', 'Burned Toast', 'Someone Yawning', 'Slipping on Banana Peel',
                'Buffering Internet', 'Zoom Meeting', 'Email Overload', 'Coffee Spill', 'Awkward Wave',

                // Random Objects
                'Umbrella', 'Glasses', 'Crown', 'Trophy', 'Guitar', 'Drum', 'Piano', 'Microphone',
                'Camera', 'Telescope', 'Magnifying Glass', 'Key', 'Lock', 'Lightbulb', 'Battery',
                'Balloon', 'Gift Box', 'Party Hat', 'Candle', 'Mirror', 'Scissors', 'Ruler',

                // Actions/Concepts (challenging!)
                'Working From Home', 'Video Call', 'Online Shopping', 'Social Media', 'Password Reset',
                'File Upload', 'Screen Share', 'Mute Button', 'Deadline', 'Brainstorming',
                'Team Meeting', 'Lunch Break', 'Happy Hour', 'Out of Office'
            ],
            currentPrompt: '',
            currentArtist: null,
            timeLeft: 60,
            timer: null,
            guesses: {},
            teamMode: false,
            teams: { teamA: [], teamB: [] },
            currentTeam: 'teamA',
            teamScores: { teamA: 0, teamB: 0 },
            roundsPlayed: 0,
            guessFeed: [],
            correctGuess: null, // { playerId, playerName, word }
            revealed: false // true if time ran out and answer was revealed
        };

        let canvas, ctx;
        let isDrawingOnCanvas = false;
        let currentColor = '#000';
        let lastX = 0;
        let lastY = 0;

        // Team selection state
        let teamSelection = {
            teamA: [],
            teamB: [],
            spymasterA: null,  // For Codenames
            spymasterB: null   // For Codenames
        };

        function showTeamSelectionScreen() {
            showScreen('teamSelectionScreen');

            // Initialize team selection with all players unassigned
            teamSelection.teamA = [];
            teamSelection.teamB = [];
            teamSelection.spymasterA = null;
            teamSelection.spymasterB = null;

            renderTeamSelection();

            // Broadcast to all clients to show the team selection screen
            if (gameState.isHost) {
                broadcast({
                    type: 'showTeamSelection',
                    game: gameState.currentGame
                });
            }
        }

        function renderTeamSelection() {
            const teamAList = document.getElementById('teamAList');
            const teamBList = document.getElementById('teamBList');
            const unassignedList = document.getElementById('unassignedList');

            teamAList.innerHTML = '';
            teamBList.innerHTML = '';
            unassignedList.innerHTML = '';

            const allPlayerIds = Object.keys(gameState.players);
            const unassigned = allPlayerIds.filter(id =>
                !teamSelection.teamA.includes(id) && !teamSelection.teamB.includes(id)
            );

            const isHost = gameState.isHost;
            const isCodenames = gameState.currentGame === 'wordweb';
            const isQuickDraw = gameState.currentGame === 'quickdraw-teams';

            // Update title based on game type
            const titleElement = document.getElementById('teamSelectionTitle');
            if (titleElement) {
                if (isCodenames) {
                    titleElement.textContent = 'üïµÔ∏è Codenames - Team Selection';
                } else if (isQuickDraw) {
                    titleElement.textContent = 'üé® Quick Draw Teams - Team Selection';
                } else {
                    titleElement.textContent = 'üé® Team Selection';
                }
            }

            // Show/hide How to Play button for Codenames
            const howToPlayButton = document.getElementById('codenamesHowToPlayButton');
            if (howToPlayButton) howToPlayButton.style.display = isCodenames ? 'block' : 'none';

            // Show/hide spymaster selection for Codenames
            const teamASpymasterSection = document.getElementById('teamASpymasterSection');
            const teamBSpymasterSection = document.getElementById('teamBSpymasterSection');
            if (teamASpymasterSection) teamASpymasterSection.style.display = isCodenames ? 'block' : 'none';
            if (teamBSpymasterSection) teamBSpymasterSection.style.display = isCodenames ? 'block' : 'none';

            // Populate spymaster dropdowns for Codenames
            if (isCodenames) {
                const teamASpymasterSelect = document.getElementById('teamASpymaster');
                const teamBSpymasterSelect = document.getElementById('teamBSpymaster');

                if (teamASpymasterSelect) {
                    teamASpymasterSelect.innerHTML = '<option value="">Select Spymaster...</option>';
                    teamSelection.teamA.forEach(playerId => {
                        const player = gameState.players[playerId];
                        const option = document.createElement('option');
                        option.value = playerId;
                        option.textContent = player.name;
                        if (playerId === teamSelection.spymasterA) {
                            option.selected = true;
                        }
                        teamASpymasterSelect.appendChild(option);
                    });
                    // Disable if not host
                    teamASpymasterSelect.disabled = !isHost;
                }

                if (teamBSpymasterSelect) {
                    teamBSpymasterSelect.innerHTML = '<option value="">Select Spymaster...</option>';
                    teamSelection.teamB.forEach(playerId => {
                        const player = gameState.players[playerId];
                        const option = document.createElement('option');
                        option.value = playerId;
                        option.textContent = player.name;
                        if (playerId === teamSelection.spymasterB) {
                            option.selected = true;
                        }
                        teamBSpymasterSelect.appendChild(option);
                    });
                    // Disable if not host
                    teamBSpymasterSelect.disabled = !isHost;
                }
            }

            // Hide/show controls based on host status
            const autoAssignBtn = document.getElementById('teamSelectionAutoAssign');
            const controlButtons = document.getElementById('teamSelectionButtons');
            if (autoAssignBtn) autoAssignBtn.style.display = isHost ? 'block' : 'none';
            if (controlButtons) controlButtons.style.display = isHost ? 'block' : 'none';

            // Render Team A
            teamSelection.teamA.forEach(playerId => {
                const player = gameState.players[playerId];
                const isSpymaster = isCodenames && playerId === teamSelection.spymasterA;
                const item = document.createElement('div');
                item.style.cssText = 'padding: 10px; margin: 5px 0; background: white; border-radius: 5px; display: flex; justify-content: space-between; align-items: center;';
                item.innerHTML = `
                    <span>${player.name}${player.isHost ? ' üëë' : ''}${isSpymaster ? ' üëÅÔ∏è' : ''}</span>
                    ${isHost ? `<button onclick="removeFromTeam('${playerId}', 'teamA')" style="padding: 5px 10px;">Remove</button>` : ''}
                `;
                teamAList.appendChild(item);
            });

            // Render Team B
            teamSelection.teamB.forEach(playerId => {
                const player = gameState.players[playerId];
                const isSpymaster = isCodenames && playerId === teamSelection.spymasterB;
                const item = document.createElement('div');
                item.style.cssText = 'padding: 10px; margin: 5px 0; background: white; border-radius: 5px; display: flex; justify-content: space-between; align-items: center;';
                item.innerHTML = `
                    <span>${player.name}${player.isHost ? ' üëë' : ''}${isSpymaster ? ' üëÅÔ∏è' : ''}</span>
                    ${isHost ? `<button onclick="removeFromTeam('${playerId}', 'teamB')" style="padding: 5px 10px;">Remove</button>` : ''}
                `;
                teamBList.appendChild(item);
            });

            // Render Unassigned
            unassigned.forEach(playerId => {
                const player = gameState.players[playerId];
                const item = document.createElement('div');
                item.style.cssText = 'padding: 10px; margin: 5px 0; background: white; border-radius: 5px; display: flex; justify-content: space-between; align-items: center;';
                item.innerHTML = `
                    <span>${player.name}${player.isHost ? ' üëë' : ''}</span>
                    ${isHost ? `<div>
                        <button onclick="addToTeam('${playerId}', 'teamA')" style="padding: 5px 10px; background: #667eea; color: white; border: none; border-radius: 3px; margin-right: 5px;">Team A</button>
                        <button onclick="addToTeam('${playerId}', 'teamB')" style="padding: 5px 10px; background: #764ba2; color: white; border: none; border-radius: 3px;">Team B</button>
                    </div>` : ''}
                `;
                unassignedList.appendChild(item);
            });
        }

        function addToTeam(playerId, team) {
            if (!gameState.isHost) return;

            if (team === 'teamA') {
                teamSelection.teamA.push(playerId);
            } else {
                teamSelection.teamB.push(playerId);
            }
            renderTeamSelection();
            broadcastTeamSelection();
        }

        function removeFromTeam(playerId, team) {
            if (!gameState.isHost) return;

            if (team === 'teamA') {
                teamSelection.teamA = teamSelection.teamA.filter(id => id !== playerId);
                // Clear spymaster if this player was the spymaster
                if (teamSelection.spymasterA === playerId) {
                    teamSelection.spymasterA = null;
                }
            } else {
                teamSelection.teamB = teamSelection.teamB.filter(id => id !== playerId);
                // Clear spymaster if this player was the spymaster
                if (teamSelection.spymasterB === playerId) {
                    teamSelection.spymasterB = null;
                }
            }
            renderTeamSelection();
            broadcastTeamSelection();
        }

        function updateSpymaster(team, playerId) {
            if (!gameState.isHost) return;

            if (team === 'teamA') {
                teamSelection.spymasterA = playerId || null;
            } else if (team === 'teamB') {
                teamSelection.spymasterB = playerId || null;
            }

            renderTeamSelection();
            broadcastTeamSelection();
        }

        function autoAssignTeams() {
            if (!gameState.isHost) return;

            const allPlayerIds = Object.keys(gameState.players);
            const shuffled = [...allPlayerIds].sort(() => Math.random() - 0.5);
            const mid = Math.ceil(shuffled.length / 2);

            teamSelection.teamA = shuffled.slice(0, mid);
            teamSelection.teamB = shuffled.slice(mid);

            // Auto-assign spymasters for Codenames
            if (gameState.currentGame === 'wordweb') {
                teamSelection.spymasterA = teamSelection.teamA[0];
                teamSelection.spymasterB = teamSelection.teamB[0];
            }

            renderTeamSelection();
            broadcastTeamSelection();
        }

        function broadcastTeamSelection() {
            if (!gameState.isHost) return;

            broadcast({
                type: 'updateTeamSelection',
                teamA: teamSelection.teamA,
                teamB: teamSelection.teamB,
                spymasterA: teamSelection.spymasterA,
                spymasterB: teamSelection.spymasterB
            });
        }

        function startSelectedTeamGame() {
            if (gameState.currentGame === 'quickdraw-teams') {
                startQuickdrawWithTeams();
            } else if (gameState.currentGame === 'wordweb') {
                startCodenamesWithTeams();
            }
        }

        function cancelTeamSelection() {
            if (!gameState.isHost) return;

            gameState.currentGame = null;
            showScreen('lobbyScreen');

            // Broadcast to all clients to return to lobby
            broadcast({
                type: 'cancelTeamSelection'
            });
        }

        function startQuickdrawWithTeams() {
            // Validate teams
            if (teamSelection.teamA.length === 0 || teamSelection.teamB.length === 0) {
                alert('Both teams must have at least one player!');
                return;
            }

            // Initialize game with manual team assignment
            const gameData = initQuickdrawGameWithTeams(teamSelection.teamA, teamSelection.teamB);

            broadcast({
                type: 'startGame',
                game: 'quickdraw-teams',
                gameData: gameData
            });
        }

        function initQuickdrawGameWithTeams(teamAPlayers, teamBPlayers) {
            showScreen('quickdrawScreen');

            quickdrawGameState.teamMode = true;
            quickdrawGameState.roundsPlayed = 0;

            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');
            clearCanvas();

            // Setup canvas events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', stopDrawing);

            // Set manual team assignments
            quickdrawGameState.teams.teamA = teamAPlayers;
            quickdrawGameState.teams.teamB = teamBPlayers;
            quickdrawGameState.currentTeam = 'teamA';
            quickdrawGameState.teamScores = { teamA: 0, teamB: 0 };

            // Pick random drawer from current team
            const currentTeamPlayers = quickdrawGameState.teams[quickdrawGameState.currentTeam];
            quickdrawGameState.currentArtist = currentTeamPlayers[Math.floor(Math.random() * currentTeamPlayers.length)];

            document.getElementById('quickdrawTeamIndicator').style.display = 'block';

            quickdrawGameState.currentPrompt = quickdrawGameState.prompts[Math.floor(Math.random() * quickdrawGameState.prompts.length)];
            quickdrawGameState.timeLeft = 60;
            quickdrawGameState.guesses = {};
            quickdrawGameState.guessFeed = [];
            quickdrawGameState.correctGuess = null;
            quickdrawGameState.revealed = false;

            if (gameState.isHost) {
                document.getElementById('quickdrawHostControls').style.display = 'block';
                startDrawingTimer();
            }

            updateQuickdrawUI();

            return quickdrawGameState;
        }

        function initQuickdrawGame(teamMode = false) {
            showScreen('quickdrawScreen');

            quickdrawGameState.teamMode = teamMode;
            quickdrawGameState.roundsPlayed = 0;

            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');
            clearCanvas();

            // Setup canvas events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', stopDrawing);

            const players = Object.keys(gameState.players);

            if (teamMode) {
                // Auto-assign players to teams
                const shuffled = [...players].sort(() => Math.random() - 0.5);
                const mid = Math.ceil(shuffled.length / 2);
                quickdrawGameState.teams.teamA = shuffled.slice(0, mid);
                quickdrawGameState.teams.teamB = shuffled.slice(mid);
                quickdrawGameState.currentTeam = 'teamA';
                quickdrawGameState.teamScores = { teamA: 0, teamB: 0 };

                // Pick random drawer from current team
                const currentTeamPlayers = quickdrawGameState.teams[quickdrawGameState.currentTeam];
                quickdrawGameState.currentArtist = currentTeamPlayers[Math.floor(Math.random() * currentTeamPlayers.length)];

                document.getElementById('quickdrawTeamIndicator').style.display = 'block';
            } else {
                // Free-for-all mode
                quickdrawGameState.currentArtist = players[Math.floor(Math.random() * players.length)];
                document.getElementById('quickdrawTeamIndicator').style.display = 'none';
            }

            quickdrawGameState.currentPrompt = quickdrawGameState.prompts[Math.floor(Math.random() * quickdrawGameState.prompts.length)];
            quickdrawGameState.timeLeft = 60;
            quickdrawGameState.guesses = {};
            quickdrawGameState.guessFeed = [];
            quickdrawGameState.correctGuess = null;
            quickdrawGameState.revealed = false;

            if (gameState.isHost) {
                document.getElementById('quickdrawHostControls').style.display = 'block';
                startDrawingTimer();
            }

            updateQuickdrawUI();

            return quickdrawGameState;
        }

        function loadQuickdrawGame(data) {
            quickdrawGameState = data;

            // Initialize canvas for clients
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');
            clearCanvas();

            // Setup canvas events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', stopDrawing);

            updateQuickdrawUI();

            if (gameState.isHost) {
                startDrawingTimer();
            }
        }

        function updateQuickdrawUI() {
            const artist = gameState.players[quickdrawGameState.currentArtist];
            const status = document.getElementById('quickdrawStatus');

            // Check if someone guessed correctly and show that message to everyone
            if (quickdrawGameState.correctGuess) {
                status.textContent = `${quickdrawGameState.correctGuess.playerName} guessed correctly with: ${quickdrawGameState.correctGuess.word}`;
                status.className = 'status-message status-success';
                // Hide guessing area when round is over
                document.getElementById('guessingArea').style.display = 'none';
                // Don't return - continue to update other UI elements
            } else if (quickdrawGameState.revealed) {
                // Time ran out - show the answer to everyone
                status.textContent = `The correct answer was: ${quickdrawGameState.currentPrompt}`;
                status.className = 'status-message status-info';
                // Hide guessing area when round is over
                document.getElementById('guessingArea').style.display = 'none';
                // Don't return - continue to update other UI elements
            } else {
                // Update team indicator if in team mode
                if (quickdrawGameState.teamMode) {
                    const teamName = quickdrawGameState.currentTeam === 'teamA' ? 'Team A' : 'Team B';
                    document.getElementById('quickdrawCurrentTeam').textContent = `${teamName}'s Turn`;
                    document.getElementById('quickdrawTeamIndicator').style.display = 'block';
                } else {
                    document.getElementById('quickdrawTeamIndicator').style.display = 'none';
                }

                if (gameState.peerId === quickdrawGameState.currentArtist) {
                    // Current player is the artist
                    status.textContent = `You're drawing: ${quickdrawGameState.currentPrompt}`;
                    status.className = 'status-message status-success';
                    document.getElementById('colorPalette').style.display = 'flex';
                    document.getElementById('guessingArea').style.display = 'none';
                } else if (quickdrawGameState.teamMode) {
                    // Team mode logic
                    const currentTeamPlayers = quickdrawGameState.teams[quickdrawGameState.currentTeam];
                    const isOnCurrentTeam = currentTeamPlayers.includes(gameState.peerId);

                    if (isOnCurrentTeam) {
                        // Player is on the guessing team
                        status.textContent = `${artist?.name || 'Someone'} is drawing... Make your guess!`;
                        status.className = 'status-message status-info';
                        document.getElementById('colorPalette').style.display = 'none';
                        document.getElementById('guessingArea').style.display = 'block';
                    } else {
                        // Player is spectating
                        status.textContent = `Spectating: ${artist?.name || 'Someone'} is drawing for the other team`;
                        status.className = 'status-message status-warning';
                        document.getElementById('colorPalette').style.display = 'none';
                        document.getElementById('guessingArea').style.display = 'none';
                    }
                } else {
                    // Free-for-all mode
                    status.textContent = `${artist?.name || 'Someone'} is drawing...`;
                    status.className = 'status-message status-info';
                    document.getElementById('colorPalette').style.display = 'none';
                    document.getElementById('guessingArea').style.display = 'block';
                }
            }

            document.getElementById('quickdrawTimer').textContent = quickdrawGameState.timeLeft;

            // Show/hide guess feed
            const guessFeedEl = document.getElementById('guessFeed');
            if (quickdrawGameState.teamMode && gameState.peerId !== quickdrawGameState.currentArtist) {
                guessFeedEl.style.display = 'block';
                updateGuessFeed();
            } else if (!quickdrawGameState.teamMode && gameState.peerId !== quickdrawGameState.currentArtist) {
                guessFeedEl.style.display = 'block';
                updateGuessFeed();
            } else {
                guessFeedEl.style.display = 'none';
            }

            // Update scoreboard
            updateQuickdrawScoreboard();
        }

        function updateGuessFeed() {
            const guessList = document.getElementById('guessList');
            if (!guessList) return;

            if (quickdrawGameState.guessFeed.length === 0) {
                guessList.innerHTML = '<div style="color: #999; font-style: italic;">No guesses yet...</div>';
                return;
            }

            // Show last 5 guesses
            const recentGuesses = quickdrawGameState.guessFeed.slice(-5).reverse();
            guessList.innerHTML = recentGuesses.map(guess => {
                const player = gameState.players[guess.playerId];
                return `<div style="padding: 5px 0; border-bottom: 1px solid #e0e0e0;">
                    <strong style="color: #667eea;">${player?.name || 'Unknown'}:</strong> ${guess.guess}
                </div>`;
            }).join('');
        }

        function updateQuickdrawScoreboard() {
            const scoreboard = document.getElementById('quickdrawScoreboard');
            if (!scoreboard) return;

            if (quickdrawGameState.teamMode) {
                // Build Team A members list
                let teamAMembers = quickdrawGameState.teams.teamA.map(playerId => {
                    const player = gameState.players[playerId];
                    return player ? player.name : 'Unknown';
                }).join(', ');

                // Build Team B members list
                let teamBMembers = quickdrawGameState.teams.teamB.map(playerId => {
                    const player = gameState.players[playerId];
                    return player ? player.name : 'Unknown';
                }).join(', ');

                // Show team scores with members
                scoreboard.innerHTML = `
                    <div class="score-item" style="flex-direction: column; align-items: flex-start;">
                        <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 5px;">
                            <span style="font-weight: bold;">Team A</span>
                            <span style="color: #667eea; font-weight: bold;">${quickdrawGameState.teamScores.teamA} pts</span>
                        </div>
                        <div style="font-size: 0.9em; color: #666;">${teamAMembers}</div>
                    </div>
                    <div class="score-item" style="flex-direction: column; align-items: flex-start;">
                        <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 5px;">
                            <span style="font-weight: bold;">Team B</span>
                            <span style="color: #764ba2; font-weight: bold;">${quickdrawGameState.teamScores.teamB} pts</span>
                        </div>
                        <div style="font-size: 0.9em; color: #666;">${teamBMembers}</div>
                    </div>
                `;
            } else {
                // Show individual scores
                updateScoreboard('quickdrawScoreboard');
            }
        }

        function startDrawingTimer() {
            if (quickdrawGameState.timer) clearInterval(quickdrawGameState.timer);

            quickdrawGameState.timer = setInterval(() => {
                quickdrawGameState.timeLeft--;

                // Update timer display on host screen
                document.getElementById('quickdrawTimer').textContent = quickdrawGameState.timeLeft;

                if (quickdrawGameState.timeLeft <= 0) {
                    clearInterval(quickdrawGameState.timer);
                    revealDrawing();
                }

                broadcastGameUpdate();
            }, 1000);
        }

        function startDrawing(e) {
            if (gameState.peerId !== quickdrawGameState.currentArtist) return;
            isDrawingOnCanvas = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function draw(e) {
            if (!isDrawingOnCanvas || gameState.peerId !== quickdrawGameState.currentArtist) return;

            ctx.strokeStyle = currentColor;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();

            // Broadcast drawing data BEFORE updating lastX/lastY
            if (gameState.isHost || gameState.peerId === quickdrawGameState.currentArtist) {
                broadcast({
                    type: 'drawingData',
                    drawData: {
                        fromX: lastX,
                        fromY: lastY,
                        toX: e.offsetX,
                        toY: e.offsetY,
                        color: currentColor
                    }
                });
            }

            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function stopDrawing() {
            isDrawingOnCanvas = false;
        }

        function handleTouch(e) {
            if (gameState.peerId !== quickdrawGameState.currentArtist) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            if (e.type === 'touchstart') {
                isDrawingOnCanvas = true;
                [lastX, lastY] = [x, y];
            } else if (e.type === 'touchmove' && isDrawingOnCanvas) {
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                broadcast({
                    type: 'drawingData',
                    drawData: {
                        fromX: lastX,
                        fromY: lastY,
                        toX: x,
                        toY: y,
                        color: currentColor
                    }
                });
                
                [lastX, lastY] = [x, y];
            }
        }

        function handleDrawingData(drawData) {
            if (!ctx) {
                console.error('Canvas context not initialized');
                return;
            }

            ctx.strokeStyle = drawData.color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(drawData.fromX, drawData.fromY);
            ctx.lineTo(drawData.toX, drawData.toY);
            ctx.stroke();
        }

        function setDrawColor(color) {
            currentColor = color;
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function clearCanvas() {
            if (ctx) {
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Broadcast clear canvas action if artist is drawing
                if (gameState.peerId === quickdrawGameState.currentArtist) {
                    broadcast({
                        type: 'clearCanvas'
                    });
                }
            }
        }

        function submitGuess() {
            const guess = document.getElementById('guessInput').value.trim().toLowerCase();
            if (!guess) return;

            if (!gameState.isHost) {
                broadcast({
                    type: 'guess',
                    playerId: gameState.peerId,
                    guess: guess
                });
            } else {
                handleGuess(gameState.peerId, guess);
            }

            document.getElementById('guessInput').value = '';
        }

        function handleGuess(playerId, guess) {
            if (!gameState.isHost) return;

            // In team mode, only allow guesses from current team members (excluding artist)
            if (quickdrawGameState.teamMode) {
                const currentTeamPlayers = quickdrawGameState.teams[quickdrawGameState.currentTeam];
                if (!currentTeamPlayers.includes(playerId) || playerId === quickdrawGameState.currentArtist) {
                    return; // Ignore guesses from wrong team or artist
                }
            }

            // Add guess to feed
            quickdrawGameState.guessFeed.push({
                playerId: playerId,
                guess: guess,
                timestamp: Date.now()
            });

            if (guess === quickdrawGameState.currentPrompt.toLowerCase()) {
                if (quickdrawGameState.teamMode) {
                    // Award points to team
                    quickdrawGameState.teamScores[quickdrawGameState.currentTeam] += 100;
                } else {
                    // Award points to individual
                    gameState.scores[playerId] = (gameState.scores[playerId] || 0) + 200;
                }

                quickdrawGameState.guesses[playerId] = true;

                // Set correct guess info for all players to see
                const player = gameState.players[playerId];
                quickdrawGameState.correctGuess = {
                    playerId: playerId,
                    playerName: player.name,
                    word: quickdrawGameState.currentPrompt
                };

                broadcastGameUpdate();
                updateQuickdrawScoreboard();
                updateQuickdrawUI(); // Update UI to show success message

                // Stop the timer when someone guesses correctly
                if (quickdrawGameState.timer) {
                    clearInterval(quickdrawGameState.timer);
                }
            } else {
                // Incorrect guess - just broadcast the update so everyone sees it
                broadcastGameUpdate();
            }
        }

        function revealDrawing() {
            if (!gameState.isHost) return;

            // Set revealed flag so all players see the message
            quickdrawGameState.revealed = true;

            broadcastGameUpdate();
            updateQuickdrawUI(); // Update UI to show reveal message
        }

        function nextDrawingRound() {
            if (!gameState.isHost) return;

            quickdrawGameState.roundsPlayed++;

            if (quickdrawGameState.teamMode) {
                // Check if both teams have played (end after 6 rounds - 3 per team)
                if (quickdrawGameState.roundsPlayed >= 6) {
                    endGame();
                    return;
                }

                // Switch teams
                quickdrawGameState.currentTeam = quickdrawGameState.currentTeam === 'teamA' ? 'teamB' : 'teamA';

                // Pick new random drawer from current team
                const currentTeamPlayers = quickdrawGameState.teams[quickdrawGameState.currentTeam];
                quickdrawGameState.currentArtist = currentTeamPlayers[Math.floor(Math.random() * currentTeamPlayers.length)];
            } else {
                // Free-for-all: pick new random drawer
                const players = Object.keys(gameState.players);
                quickdrawGameState.currentArtist = players[Math.floor(Math.random() * players.length)];

                // End after 3 rounds in FFA
                if (quickdrawGameState.roundsPlayed >= 3) {
                    endGame();
                    return;
                }
            }

            // Reset for new round
            quickdrawGameState.currentPrompt = quickdrawGameState.prompts[Math.floor(Math.random() * quickdrawGameState.prompts.length)];
            quickdrawGameState.timeLeft = 60;
            quickdrawGameState.guesses = {};
            quickdrawGameState.guessFeed = [];
            quickdrawGameState.correctGuess = null;
            quickdrawGameState.revealed = false;
            clearCanvas();

            // Broadcast clear to all players
            broadcast({ type: 'clearCanvas' });

            updateQuickdrawUI();
            startDrawingTimer();
            broadcastGameUpdate();
        }

        function updateQuickdrawGame(data) {
            quickdrawGameState = data;
            updateQuickdrawUI();
            updateQuickdrawScoreboard();
        }

        function broadcastGameUpdate() {
            if (!gameState.isHost) return;

            broadcast({
                type: 'gameUpdate',
                gameData: getCurrentGameData(),
                scores: gameState.scores
            });
        }

        // Handle Enter key for inputs
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('hostName')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') createRoom();
            });
            
            document.getElementById('playerName')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') document.getElementById('roomCode').focus();
            });
            
            document.getElementById('roomCode')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') joinRoom();
            });
            
            document.getElementById('guessInput')?.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') submitGuess();
            });
        });
    </script>
</body>
</html>
